// src/app/AppConfig.cpp
#include "AppConfig.h"
#include "core/Logger.h"
#include "core/Utils.h"
#include <fstream>
#include <sstream>
#include <windows.h>

AppConfig::AppConfig()
{
    m_configFile = GetConfigFilePath();
    SetDefaults();
}

AppConfig::~AppConfig()
{
    if (m_isDirty)
    {
        Save();
    }
}

bool AppConfig::Load()
{
    std::ifstream file(m_configFile);
    if (!file.is_open())
    {
        Logger::Info("Config file not found, using defaults: {}", m_configFile);
        return true; // Not an error, just use defaults
    }
    
    std::string line;
    while (std::getline(file, line))
    {
        if (!ParseConfigLine(line))
        {
            Logger::Warning("Failed to parse config line: {}", line);
        }
    }
    
    file.close();
    m_isDirty = false;
    
    Logger::Info("Configuration loaded from: {}", m_configFile);
    return true;
}

bool AppConfig::Save()
{
    // Ensure directory exists
    std::string configDir = Utils::GetDirectoryPath(m_configFile);
    if (!configDir.empty() && !Utils::DirectoryExists(configDir))
    {
        Utils::CreateDirectoryRecursive(configDir);
    }
    
    std::ofstream file(m_configFile);
    if (!file.is_open())
    {
        Logger::Error("Failed to save config file: {}", m_configFile);
        return false;
    }
    
    // Write header
    file << "# Potensio Configuration File" << std::endl;
    file << "# This file is automatically generated" << std::endl;
    file << std::endl;
    
    // Write all key-value pairs
    for (const auto& pair : m_config)
    {
        file << pair.first << "=" << SerializeValue(pair.second) << std::endl;
    }
    
    file.close();
    m_isDirty = false;
    
    Logger::Info("Configuration saved to: {}", m_configFile);
    return true;
}

bool AppConfig::GetValue(const std::string& key, bool defaultValue) const
{
    auto it = m_config.find(key);
    if (it != m_config.end())
    {
        if (std::holds_alternative<bool>(it->second))
        {
            return std::get<bool>(it->second);
        }
    }
    return defaultValue;
}

int AppConfig::GetValue(const std::string& key, int defaultValue) const
{
    auto it = m_config.find(key);
    if (it != m_config.end())
    {
        if (std::holds_alternative<int>(it->second))
        {
            return std::get<int>(it->second);
        }
    }
    return defaultValue;
}

float AppConfig::GetValue(const std::string& key, float defaultValue) const
{
    auto it = m_config.find(key);
    if (it != m_config.end())
    {
        if (std::holds_alternative<float>(it->second))
        {
            return std::get<float>(it->second);
        }
    }
    return defaultValue;
}

std::string AppConfig::GetValue(const std::string& key, const std::string& defaultValue) const
{
    auto it = m_config.find(key);
    if (it != m_config.end())
    {
        if (std::holds_alternative<std::string>(it->second))
        {
            return std::get<std::string>(it->second);
        }
    }
    return defaultValue;
}

std::string AppConfig::GetValueString(const std::string& key, const std::string& defaultValue) const
{
    auto it = m_config.find(key);
    if (it != m_config.end())
    {
        if (std::holds_alternative<std::string>(it->second))
        {
            return std::get<std::string>(it->second);
        }
    }
    return defaultValue;
}

void AppConfig::SetValue(const std::string& key, bool value)
{
    m_config[key] = value;
    m_isDirty = true;
}

void AppConfig::SetValue(const std::string& key, int value)
{
    m_config[key] = value;
    m_isDirty = true;
}

void AppConfig::SetValue(const std::string& key, float value)
{
    m_config[key] = value;
    m_isDirty = true;
}

void AppConfig::SetValue(const std::string& key, const std::string& value)
{
    m_config[key] = value;
    m_isDirty = true;
}

bool AppConfig::HasKey(const std::string& key) const
{
    return m_config.find(key) != m_config.end();
}

void AppConfig::RemoveKey(const std::string& key)
{
    if (m_config.erase(key) > 0)
    {
        m_isDirty = true;
    }
}

void AppConfig::Clear()
{
    m_config.clear();
    SetDefaults();
    m_isDirty = true;
}

void AppConfig::SetDefaults()
{
    // Application defaults
    m_config["app.startWithWindows"] = false;
    m_config["app.minimizeToTray"] = true;
    m_config["app.showNotifications"] = true;
    
    // UI defaults
    m_config["ui.fontSize"] = 13.0f;
    m_config["ui.sidebarWidth"] = 90;
    m_config["ui.theme"] = std::string("dark");
    
    // Window defaults
    m_config["window.x"] = 100;
    m_config["window.y"] = 100;
    m_config["window.width"] = 1000;
    m_config["window.height"] = 700;
    m_config["window.maximized"] = false;
    
    // Hotkey defaults (Ctrl+Shift+Q)
    m_config["hotkeys.toggleWindow.enabled"] = true;
    m_config["hotkeys.toggleWindow.modifiers"] = 6; // MOD_CONTROL | MOD_SHIFT
    m_config["hotkeys.toggleWindow.key"] = 80; // 'P'
}

std::string AppConfig::GetConfigFilePath() const
{
    char exePath[MAX_PATH];
    GetModuleFileNameA(NULL, exePath, MAX_PATH);

    std::string path(exePath);

    // Strip off the executable name, leaving only the directory
    size_t pos = path.find_last_of("\\/");
    if (pos != std::string::npos)
    {
        path = path.substr(0, pos);
    }

    return path + "\\config.txt";  // join with config.txt
}
// std::string AppConfig::GetConfigFilePath() const
// {
//     std::string appDataPath = Utils::GetAppDataPath();
//     return Utils::JoinPath(appDataPath, "config.txt");
// }

bool AppConfig::ParseConfigLine(const std::string& line)
{
    // Skip empty lines and comments
    std::string trimmed = Utils::Trim(line);
    if (trimmed.empty() || trimmed[0] == '#')
    {
        return true;
    }
    
    // Find the equals sign
    size_t equalPos = trimmed.find('=');
    if (equalPos == std::string::npos)
    {
        return false;
    }
    
    std::string key = Utils::Trim(trimmed.substr(0, equalPos));
    std::string valueStr = Utils::Trim(trimmed.substr(equalPos + 1));
    
    // Parse the value based on the key name or content
    if (key.find("enabled") != std::string::npos || 
        key.find("minimizeToTray") != std::string::npos ||
        key.find("showNotifications") != std::string::npos ||
        key.find("startWithWindows") != std::string::npos ||
        key.find("maximized") != std::string::npos ||
        valueStr == "true" || valueStr == "false")
    {
        // Boolean value
        m_config[key] = (valueStr == "true");
    }
    else if (valueStr.find('.') != std::string::npos)
    {
        // Float value
        try
        {
            m_config[key] = std::stof(valueStr);
        }
        catch (const std::exception&)
        {
            return false;
        }
    }
    else if (valueStr.find_first_not_of("0123456789-") == std::string::npos)
    {
        // Integer value
        try
        {
            m_config[key] = std::stoi(valueStr);
        }
        catch (const std::exception&)
        {
            return false;
        }
    }
    else
    {
        // String value
        m_config[key] = valueStr;
    }
    
    return true;
}

std::string AppConfig::SerializeValue(const ConfigValue& value) const
{
    if (std::holds_alternative<bool>(value))
    {
        return std::get<bool>(value) ? "true" : "false";
    }
    else if (std::holds_alternative<int>(value))
    {
        return std::to_string(std::get<int>(value));
    }
    else if (std::holds_alternative<float>(value))
    {
        return std::to_string(std::get<float>(value));
    }
    else if (std::holds_alternative<std::string>(value))
    {
        return std::get<std::string>(value);
    }
    
    return "";
}